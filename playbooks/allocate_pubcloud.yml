---
- hosts: localhost
  connection: local
  gather_facts: False
  vars:
    keyname: "jenkins"
    inventory_path: "{{ lookup('env', 'WORKSPACE') }}/rpc-gating/playbooks/inventory"
    user_data_path: "{{ lookup('env', 'WORKSPACE') }}/rpc-gating/scripts/user_data_pubcloud.sh"
    cloud_name: "public_cloud"
    boot_timeout: "{{ lookup('env', 'BOOT_TIMEOUT') | default(900, true) }}"
  tasks:

    - name: Create inventory directory
      file:
        path: "{{ inventory_path }}"
        state: directory

    # regions, and fallback_regions should be CSV strings
    # We randomly shuffle them both, then use the first
    # item of the resulting lists for the try/rescue block.

    - name: Create primary region list
      set_fact:
        # replace: replace commas with spaces. Double spaces will be removed by trim or select.
        # split on spaces to produce a list
        # trim: remove spaces from beginning and end of each item
        # upper: convert to upper case
        # select: remove empty strings from the list
        # shuffle: randomise order
        regions_shuff: "{{ (regions|replace(',', ' ')).split()|map('trim')|map('upper')|select|shuffle }}"

    - name: Create fallback region list
      set_fact:
        # difference: ensure that the fallback regions list does not include any items from
        #             the primary regions list
        fallback_regions_shuff: "{{ (fallback_regions|replace(',', ' ')).split()|map('trim')|map('upper')|select|difference(regions_shuff)|shuffle }}"

    - name: Provision a cloud instance
      block:
        - name: Output the primary region list
          debug:
            msg: "Job-provided primary regions: {{ regions }}; Resulting shuffled regions: {{ regions_shuff }}"

        - name: Fail when no primary regions are provided
          fail:
            msg: "No primary regions were provided. Please review job configuration."
          when:
            - regions_shuff | length == 0

        - name: Provision a cloud instance (first primary region)
          os_server:
            name: "{{ instance_name }}"
            flavor: "{{ flavor }}"
            state: present
            cloud: "{{ cloud_name }}"
            region_name: "{{ regions_shuff[0] }}"
            image: "{{ image }}"
            key_name: "{{ keyname }}"
            userdata: "{{ lookup('file', user_data_path) }}"
            config_drive: yes
            meta:
              build_config: core
            wait: yes
            timeout: "{{ boot_timeout }}"
          register: _instance_provision

        - name: Write inventory
          copy:
            content: |
              [job_nodes:children]
              hosts

              [hosts]
              {{ _instance_provision.server.name }} ansible_host={{ _instance_provision.server.accessIPv4 }} ansible_user=root rax_region={{ _instance_provision.server.region }}
            dest: '{{ inventory_path }}/hosts'

        - name: Wait for SSH connectivity to the cloud instance (10 min timeout)
          wait_for:
            timeout: 600
            port: 22
            host: "{{ _instance_provision.server.accessIPv4 }}"
            sleep: 10
            search_regex: "OpenSSH"

      rescue:
        - name: Ensure first attempt instance is removed.
          os_server:
            name: "{{ instance_name }}"
            state: absent
            cloud: "{{ cloud_name }}"
            region_name: "{{ regions_shuff[0] }}"
            wait: yes
            timeout: "{{ boot_timeout }}"

        - name: Output the fallback region list
          debug:
            msg: "Job-provided secondary regions: {{ fallback_regions }}; Resulting shuffled regions: {{ fallback_regions_shuff }}"

        - name: Fail when no fallback regions are provided
          fail:
            msg: "No fallback regions were provided. Please review job configuration."
          when:
            - fallback_regions_shuff | length == 0

        - name: Provision a cloud instance (first fallback region)
          os_server:
            name: "{{ instance_name }}"
            flavor: "{{ flavor }}"
            state: present
            cloud: "{{ cloud_name }}"
            region_name: "{{ fallback_regions_shuff[0] }}"
            image: "{{ image }}"
            key_name: "{{ keyname }}"
            userdata: "{{ lookup('file', user_data_path) }}"
            config_drive: yes
            meta:
              build_config: core
            wait: yes
            timeout: "{{ boot_timeout }}"
          register: _instance_provision

        - name: Write inventory
          copy:
            content: |
              [job_nodes:children]
              hosts

              [hosts]
              {{ _instance_provision.server.name }} ansible_host={{ _instance_provision.server.accessIPv4 }} ansible_user=root rax_region={{ _instance_provision.server.region }}
            dest: '{{ inventory_path }}/hosts'

        - name: Wait for SSH connectivity to the fallback cloud instance (10 min timeout)
          wait_for:
            timeout: 600
            port: 22
            host: "{{ _instance_provision.server.accessIPv4 }}"
            sleep: 10
            search_regex: "OpenSSH"

    - name: Show results of instance provision task
      debug:
        var: _instance_provision

    - name: Add Host
      add_host:
        hostname: "singleuseslave"
        ansible_ssh_host: "{{ _instance_provision.server.accessIPv4 }}"

    - name: Show generated inventory
      debug:
        msg: "Generated inventory: {{ lookup('file', inventory_path+'/hosts')}}"

    - name: Wait for host preparation to complete
      pause:
        minutes: 5

# Note(odyssey4me):
# We use the raw module for this Ansible play because
# we do not know if python and python-yaml are on the
# system yet, and Ansible requires those installed to
# use any modules other than raw.
- hosts: singleuseslave
  remote_user: root
  gather_facts: False
  tasks:
    - name: Check whether python is present on the host
      raw: |
        if [[ -e /usr/bin/python ]]; then
          echo -n yes
        else
          echo -n no
        fi
      register: _python_check

    - name: Show the results of the python check
      debug:
        var: _python_check

    - name: Install python onto the host if it is not already present
      when:
        - "not (_python_check.stdout | trim) | bool"
      block:
        # To assist with debugging any problems if there
        # is an apt failure, we set enable debugging.
        - name: Add apt debug configuration
          raw: echo 'Debug::Acquire::http "true";' > /etc/apt/apt.conf.d/99debug
          args:
            executable: /bin/bash

        # The apt sources in the OnMetal builds uses
        # archive.ubuntu.com which has turned out to
        # be a bit unreliable in providing complete
        # data back when doing apt updates/installs.
        # We prefer our local mirror which provides
        # us with reliable and quick responses.
        # ref: RE-1758
        - name: Reconfigure the host to use Rackspace Mirrors
          raw: |
            mv /etc/apt/sources.list /etc/apt/sources.list.original
            DISTRO_MIRROR="http://mirror.rackspace.com/ubuntu"
            DISTRO_COMPONENTS="main,universe"
            if [[ -e /etc/lsb-release ]]; then
              source /etc/lsb-release
              DISTRO_RELEASE=${DISTRIB_CODENAME}
            elif [[ -e /etc/os-release ]]; then
              source /etc/os-release
              DISTRO_RELEASE=${UBUNTU_CODENAME}
            else
              echo "Unable to determine distribution due to missing lsb/os-release files."
              exit 1
            fi
            cat << EOF >/etc/apt/sources.list
            deb ${DISTRO_MIRROR} ${DISTRO_RELEASE} ${DISTRO_COMPONENTS//,/ }
            deb ${DISTRO_MIRROR} ${DISTRO_RELEASE}-updates ${DISTRO_COMPONENTS//,/ }
            deb ${DISTRO_MIRROR} ${DISTRO_RELEASE}-backports ${DISTRO_COMPONENTS//,/ }
            deb ${DISTRO_MIRROR} ${DISTRO_RELEASE}-security ${DISTRO_COMPONENTS//,/ }
            EOF
          args:
            executable: /bin/bash

        - name: Update apt cache
          raw: apt-get update
          args:
            executable: /bin/bash
          register: _update_cache
          until: _update_cache | success
          retries: 3
          delay: 15

        # We check to see whether the packages are available
        # and where they will come from.
        # ref: RE-1758
        - name: Check the package candidates
          raw: apt-cache policy python-minimal python-yaml
          args:
            executable: /bin/bash
          register: _package_candidates

        - name: Show the package candidates
          debug:
            var: _package_candidates

        - name: Install minimal Ansible requirements so that Ansible can be used to setup the slave
          raw: apt-get install -y python-minimal python-yaml
          args:
            executable: /bin/bash
          register: _install_packages
          until: _install_packages | success
          retries: 3
          delay: 15

- hosts: singleuseslave
  tasks:
    - name: Check for thaw hook
      stat:
        path: /gating/thaw/run
      register: thaw

    - name: Execute thaw hook
      shell: |
        set -xeu
        /gating/thaw/run
      args:
        executable: /bin/bash
      when: thaw.stat.exists|bool
